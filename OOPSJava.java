//Java Notes
//Java is a high-level, class-based, object-oriented programming language that is designed to have as few implementation dependencies as possible. It is a general-purpose programming language intended to let application developers write once, run anywhere (WORA), meaning that compiled Java code can run on all platforms that support Java without the need for recompilation.
//Java is a programming language and computing platform first released by Sun Microsystems in 1995. There are lots of applications and websites that will not work unless you have Java installed, and more are created every day. Java is fast, secure, and reliable. From laptops to datacenters, game consoles to scientific supercomputers, cell phones to the Internet, Java is everywhere!
//Java is a class-based, object-oriented programming language that is designed to have as few implementation dependencies as possible. It is a general-purpose programming language intended to let application developers write once, run anywhere (WORA), meaning that compiled Java code can run on all platforms that support Java without the need for recompilation. Java applications are typically compiled to bytecode that can run on any Java virtual machine (JVM) regardless of the underlying computer architecture.
//Java is a high-level programming language originally developed by Sun Microsystems and released in 1995. Java runs on a variety of platforms, such as Windows, Mac OS, and the various versions of UNIX. This tutorial gives a complete understanding of Java. This reference will take you through simple and practical approaches while learning Java Programming language.

//Features of Java:
//1. Simple: Java is easy to learn and its syntax is simple, clean, and easy to understand.
//2. Object-Oriented: Java is an object-oriented programming language.
//3. Platform-Independent: Java is platform-independent because it is different from other languages like C, C++, etc. which are compiled into platform-specific machines while Java is a write once, run anywhere language.
//4. Secure: Java is best known for its security. With Java, we can develop virus-free systems.
//5. Architecture-Neutral: Java is architecture-neutral because it does not depend on the architecture of the platform.
//6. Portable: Java is portable because it facilitates you to carry the Java bytecode to any platform.
//7. Robust: Java is robust because it uses strong memory management.
//8. Multithreaded: Java is multithreaded because it is capable of executing two or more threads simultaneously.

//Java Environment Setup:
//1. Install J DK: To install Java, you need to download JDK (Java Development Kit) from the Oracle website.
//2. Set Path: After installing JDK, you need to set the path of the JDK.
//3. Install IDE: To write and execute Java programs, you need an IDE (Integrated Development Environment) like Eclipse, NetBeans, etc.

//Java Syntax:
//1. Case Sensitivity: Java is case-sensitive.
//2. Class Names: For all class names, the first letter should be in Upper Case.
//3. Method Names: All method names should start with a Lower Case letter.
//4. Program File Name: The name of the program file should exactly match the class name.
//5. public static void main(String args[]): Java program processing starts from the main() method which is a mandatory part of every Java program.

//Java Identifiers:
//1. All Java components require names. Names used for classes, variables, and methods are called identifiers.
//2. In Java, there are several points to remember about identifiers. They are as follows:
//3. All identifiers should begin with a letter (A to Z or a to z), currency character ($) or an underscore (_).
//4. After the first character, identifiers can have any combination of characters.
//5. A key word cannot be used as an identifier.

//Java Modifiers:
//1. Access Modifiers: default, public, protected, private
//2. Non-Access Modifiers: final, abstract, strictfp

//Java Variables:
//1. Variable is a name of memory location.
//2. There are three types of variables in Java: local, instance, and static.
//3. There are two types of data types in Java: primitive and non-primitive.
//4. Primitive data types include byte, short, int, long, float, double, boolean, and char.
//5. Non-primitive data types include classes, arrays, and interfaces.

//Java Arrays:
//1. An array is a collection of similar type of elements.
//2. The elements of an array are stored in contiguous memory locations.
//3. The size of an array must be specified while declaring an array.
//4. The size of an array is fixed.
//5. The elements of an array can be accessed using an index.
//6. The index of an array starts from 0.
//7. The length of an array can be found using the length attribute.

//Java Operators:
//1. Operators are used to perform operations on variables and values.
//2. There are several types of operators in Java: arithmetic, relational, logical, bitwise, assignment, and ternary operators.
//3. The arithmetic operators include +, -, *, /, %, ++, and --.
//4. The relational operators include ==, !=, >, <, >=, and <=.
//5. The logical operators include &&, ||, and !.
//6. The bitwise operators include &, |, ^, ~, <<, >>, and >>>.
//7. The assignment operators include =, +=, -=, *=, /=, %=, &=, |=, ^=, <<=, >>=, and >>>=.
//8. The ternary operator is a conditional operator.

//Java If-Else:
//1. The if-else statement is used to execute a block of code if a condition is true.
//2. The if-else statement is used to execute a block of code if the condition is false.

//Java Switch:
//1. The switch statement is used to execute one statement from multiple conditions.
//2. The switch statement works with byte, short, int, long, enum types, String, and some wrapper types like Byte, Short, Int, and Long.

//Java Loops:
//1. The loops are used to execute a block of code repeatedly.
//2. There are three types of loops in Java: for, while, and do-while.
//3. The for loop is used to execute a block of code a specified number of times.
//4. The while loop is used to execute a block of code repeatedly as long as a condition is true.
//5. The do-while loop is used to execute a block of code repeatedly as long as a condition is true.

//Java Break:
//1. The break statement is used to terminate the loop or switch statement.
//2. The break statement is used inside the loop or switch statement.

//Java Continue:
//1. The continue statement is used to skip the current iteration of the loop.
//2. The continue statement is used inside the loop.

//Java Comments:
//1. Comments are used to describe the code.
//2. Comments are ignored by the compiler.
//3. There are three types of comments in Java: single-line, multi-line, and documentation comments.

//Java Classes and Objects:
//1. A class is a blueprint for objects.
//2. A class can have fields, methods, constructors, blocks, and classes.
//3. Fields are variables.

//Java Constructors:
//1. A constructor is a special type of method that is used to initialize the object.
//2. It has the same name as the class name.
//3. It does not have any return type.
//4. It is called when the object is created.
//5. It is used to initialize the instance variable of the class.
//6. It is used to allocate memory to the object.

//Java Methods:
//1. A method is a block of code that is executed when it is called.
//2. A method is used to perform a specific task.
//3. A method can have parameters.
//4. A method can return a value.
//5. A method can be of two types: built-in and user-defined.

//Java Access Modifiers:
//1. Access modifiers are used to set the visibility of classes, methods, and fields.
//2. There are four types of access modifiers in Java: default, public, protected, and private.

//Java Inheritance:
//1. Inheritance is a mechanism in which one class acquires the properties and behavior of another class.
//2. It is used to reuse the code.
//3. It is used to implement the IS-A relationship.
//4. It is used to implement the concept of polymorphism.

//Java Polymorphism:
//1. Polymorphism is a concept of performing a single action in different ways.
//2. It is used to perform a single action in different ways.
//3. It is used to perform a single action in multiple ways.
//4. It is used to perform a single action in different ways.

//Java Abstraction:
//1. Abstraction is a mechanism in which we hide the implementation details and show only the functionality.
//2. It is used to hide the implementation details and show only the functionality.
//3. It is used to hide the implementation details and show only the functionality.
//4. It is used to hide the implementation details and show only the functionality.

//Java Encapsulation:
//1. Encapsulation is a mechanism in which we bind the data (variables) and code (methods) together.
//2. It is used to bind the data (variables) and code (methods) together.
//3. It is used to bind the data (variables) and code (methods) together.
//4. It is used to bind the data (variables) and code (methods) together.

//Java Interface:
//1. An interface is a reference type in Java.
//2. It is similar to the class.
//3. It is a collection of abstract methods.
//4. It is used to achieve abstraction and multiple inheritance.

//Java Packages:
//1. A package is a namespace that organizes a set of related classes and interfaces.
//2. It is used to categorize the classes and interfaces so that they can be easily maintained.

//Java Exception Handling:
//1. An exception is an event that occurs during the execution of a program that disrupts the normal flow of instructions.
//2. It is used to handle the runtime errors.

//Java File Handling:
//1. File handling is used to read from and write to a file.
//2. It is used to read from and write to a file.

//Java Multithreading:
//1. Multithreading is a process of executing multiple threads simultaneously.
//2. It is used to execute multiple threads simultaneously.

//Java Networking:
//1. Networking is a concept of connecting two or more computing devices together.
//2. It is used to connect two or more computing devices together.

//Java AWT:
//1. AWT (Abstract Window Toolkit) is a package in Java that is used to create graphical user interfaces.
//2. It is used to create graphical user interfaces.

//Java Swing:
//1. Swing is a part of the Java Foundation Classes (JFC) that is used to create window-based applications.
//2. It is used to create window-based applications.
//Java Applet:
//1. An applet is a Java program that runs in a web browser.
//2. It is used to run Java programs in a web browser.

//Java Reflection:
//1. Reflection is a mechanism in which we can inspect classes, interfaces, fields, and methods at runtime.
//2. It is used to inspect classes, interfaces, fields, and methods at runtime.

//Java Collection Framework:
//1. The collection framework is a unified architecture that is used to store and manipulate a group of objects.
//2. It is used to store and manipulate a group of objects.

//Java Generics:
//1. Generics is a concept of writing a class or method that can work with any type of data.
//2. It is used to write a class or method that can work with any type of data.

//Java Annotations:
//1. Annotations are used to provide metadata to the program.
//2. It is used to provide metadata to the program.

//Java Design Patterns:
//1. Design patterns are used to solve common design problems.
//2. It is used to solve common design problems.

//Java Best Practices:
//1. Best practices are used to write efficient and optimized code.
//2. It is used to write efficient and optimized code.

import java.util.*;

public class OOPSJava {
    // class is collection of data memeber and member function

    int a = 5; // instance var //var of class

    void display() {
        System.out.println("Hello World");

    }

    void display2(int p) {
        System.out.println(p);
    }

    public static void main(String[] arg) {

        int b = 10; // local var //var of method

        OOPSJava obj = new OOPSJava(); // object of class
        obj.display(); // calling method //control goes to display method

        System.out.println(obj.a); // calling instance var
        System.out.println(b); // calling local var
        System.out.println(obj.a + b); // calling instance and local var

        // Object: runtime entity of class. It is used to access the members of class.

    }
}

class OOPSJava2 {
    public static void main(String[] arg) {
        OOPSJava obj = new OOPSJava(); // object of class
        obj.display(); // calling method //control goes to display method

        System.out.println(obj.a); // calling instance var

        System.out.println("Hello World");

        int p = 10222222;
        obj.display2(p); // call by value //passing value of p //p is actual parameter //p is copied to p
                         // of display2 method

    }
}

class OOPSJava3 {
    int fact(int num) {
        int f = 1;
        for (int i = num; i > 1; i--) {
            f = f * i;
        }
        return f; // returning value of f
    }

    int factFun(int num) {
        if (num == 1) {
            return 1;
        } else {
            return num * factFun(num - 1); // recursion
        }
    }

    public static void main(String[] arg) {
        int a = 10;
        OOPSJava3 obj = new OOPSJava3();
        int res = obj.fact(a); // calling and catching return value of fact method
        System.out.println(res);

        int res2 = obj.factFun(a);
        System.out.println(res2);

    }
}

// Constructor:
// 1. It is a special type of method which is used to initialize the object.
// 2. It has the same name as the class name.
// 3. It does not have any return type.
// 4. It is called when the object is created.
// 5. It is used to initialize the instance variable of the class.
// 6. It is used to allocate memory to the object.

// Default Constructor:
class OOPSJava4 {
    int a;

    OOPSJava4() {
        a = 10;
    }

    public static void main(String[] arg) {
        OOPSJava4 obj = new OOPSJava4();
        System.out.println(obj.a);
    }
}

// Parameterized Constructor:
// 1. It is a constructor which has parameters.
// 2. It is used to initialize the object with the given values.
// 3. It is used to initialize the instance variable of the class.
// 4. It is used to allocate memory to the object.
class OOPSJava5 {
    int a;

    OOPSJava5(int p) {
        a = p;
    }

    public static void main(String[] arg) {
        OOPSJava5 obj = new OOPSJava5(20);
        System.out.println(obj.a);
    }
}

// If constructor is not defined in the class then compiler will create a
// default constructor.
// If constructor is private then object of class can not be created outside the
// class.
// If constructor is protected then object of class can be created in the same
// package.

// Constructor Overloading:
// 1. It is a concept of defining multiple constructors in the class.
// 2. It is used to initialize the object with different values.
// 3. It is used to initialize the instance variable of the class.
// 4. It is used to allocate memory to the object.
class OOPSJava6 {
    int a;

    OOPSJava6() {
        a = 10;
    }

    OOPSJava6(int p) {
        a = p;
    }

    public static void main(String[] arg) {
        OOPSJava6 obj = new OOPSJava6();
        System.out.println(obj.a);

        OOPSJava6 obj2 = new OOPSJava6(20);
        System.out.println(obj2.a);
    }
}

// copy constructor:
// 1. It is a constructor which takes object of the same class as a parameter.
// 2. It is used to initialize the object with the values of another object.
class OOPSJava7 {
    int a;

    OOPSJava7(int p) {
        a = p;
    }

    OOPSJava7(OOPSJava7 obj) {
        a = obj.a;
    }

    public static void main(String[] arg) {
        OOPSJava7 obj = new OOPSJava7(10);
        OOPSJava7 obj2 = new OOPSJava7(obj);
        System.out.println(obj2.a);
    }
}

// this keyword:
// 1. It is a reference variable which is used to refer to the current object.
// 2. It is used to refer to the instance variable of the class.
class OOPSJava8 {
    int a;

    OOPSJava8(int a) {
        this.a = a;
    }

    public static void main(String[] arg) {
        OOPSJava8 obj = new OOPSJava8(10);
        System.out.println(obj.a);
    }
}

// scope:
// 1. It is the region where the variable is accessible.
// 2. It is the lifetime of the variable.
// 3. It is the visibility of the variable.
// 4. It is the range of the variable.

// Local Variable:
// 1. It is declared inside the method.

// Instance Variable:
// 1. It is declared inside the class.

// Static Variable:
// 1. It is declared with the static keyword.
// 2. It is shared among all the objects of the class.

// Access Specifiers:
// 1. It is used to define the visibility of the variable.

// public: It is accessible from anywhere.
// private: It is accessible only within the class.
// protected: It is accessible within the package and outside the package
// through inheritance.
// default: It is accessible within the package only.

// Inheritance:
// 1. It is a mechanism in which one class acquires the properties and behavior
// of another class.
// 2. It is used to reuse the code.
// 3. It is used to implement the IS-A relationship.
// IS-A: It is a relationship in which one class is a subclass of another class.
// 4. It is used to implement the concept of polymorphism.

// Types of Inheritance:
// 1. Single Inheritance: It is a type of inheritance in which one class
// inherits the properties and behavior of another class.
// 2. Multilevel Inheritance: It is a type of inheritance in which one class
// inherits the properties and behavior of another class, and that class
// inherits the properties and behavior of another class.
// 3. Hierarchical Inheritance: It is a type of inheritance in which one class
// is inherited by multiple classes.
// 4. Multiple Inheritance: It is a type of inheritance in which one class
// inherits the properties and behavior of multiple classes.
// 5. Hybrid Inheritance: It is a combination of multiple inheritance and
// hierarchical inheritance.

class A {
    void display() {
        System.out.println("Class A");
    }
}

class B extends A {
    void show() {
        System.out.println("Class B");
    }

    public static void main(String[] args) {
        B obj = new B();
        obj.display();
        obj.show();
    }
}

// Method Overriding:
// 1. It is a concept of defining a method in the subclass which is already
// defined in the superclass.
// 2. It is used to provide the specific implementation of the method in the
// subclass.
// 3. It is used to implement the runtime polymorphism.

class A2 {
    void display() {
        System.out.println("Class A");
    }
}

class B2 extends A2 {
    void display() {
        System.out.println("Class B");
    }

    public static void main(String[] args) {
        B2 obj = new B2();
        obj.display();
    }
}

// Super Keyword:
// 1. It is a reference variable which is used to refer to the immediate parent class object.
// 2. It is used to access the properties and behavior of the parent class.
// 3. It is used to call the constructor of the parent class.
// 4. It is used to call the method of the parent class.

class A1 {
    int a = 10;
}

class B1 extends A1 {
    int a = 20;

    void display() {
        System.out.println(a); // 20
        System.out.println(super.a); // 10
    }

    public static void main(String[] args) {
        B1 obj = new B1();
        obj.display();
    }
}

// Abstract Class:
// 1. It is a class which is declared with the abstract keyword.
// 2. It can have abstract methods and non-abstract methods.

abstract class A3 {

    abstract void display(); // abstract method //no body //no implementation

    void show() // non-abstract method //body //implementation
    {
        System.out.println("Non-abstract method");
    }
}

class B3 extends A3 {
    void display() {
        System.out.println("Abstract method");
    }

    public static void main(String[] args) {
        B3 obj = new B3();
        obj.display();
        obj.show();
    }
}

// Interface:
// 1. It is a reference type in Java.
// 2. It is similar to the class.
// 3. It is a collection of abstract methods.
// 4. It is used to achieve abstraction and multiple inheritance.

interface InterfaceA {
    void display();
}

class B4 implements InterfaceA {
    public void display() {
        System.out.println("Implementing display method");
    }

    public static void main(String[] args) {
        B4 obj = new B4();
        obj.display();
    }
}

// Diamond Problem:
// 1. It is a problem that occurs in multiple inheritance.
// 2. It occurs when a class inherits from two classes that have a common base
// class.
// 3. It creates ambiguity in the program.
// Diamond Problem in Java:
interface InterfaceA1 {
    void commonMethod();
}

interface InterfaceB1 {
    void commonMethod();
}

class MyClass1 implements InterfaceA1, InterfaceB1 {
    public void commonMethod() {
        System.out.println("Implementing commonMethod");
    }
}

class Main {
    public static void main(String[] args) {
        MyClass1 obj = new MyClass1();
        obj.commonMethod();
    }
}

// pattern
// *
// **
// ***
// ****
// *****
class Pattern {
    public static void main(String[] args) {
        for (int i = 1; i <= 5; i++) {
            for (int j = 1; j <= i; j++) {
                System.out.print("*");
            }
            System.out.println();
        }
    }
}

// 0
// 01
// 012
// 0123
// 01234
class Pattern2 {
    public static void main(String[] args) {
        for (int i = 0; i < 5; i++) {
            for (int j = 0; j <= i; j++) {
                System.out.print(j);
            }
            System.out.println();
        }
    }
}

// A
// AB
// ABC
// ABCD
// ABCDE
class Pattern3 {
    public static void main(String[] args) {
        for (int i = 65; i < 70; i++) {
            for (int j = 65; j <= i; j++) {
                System.out.print((char) j);
            }
            System.out.println();
        }
    }
}

// A
// BA
// CBA
// DCBA
// EDCBA
class Pattern4 {
    public static void main(String[] args) {
        for (int i = 65; i < 70; i++) {
            for (int j = i; j >= 65; j--) {
                System.out.print((char) j);
            }
            System.out.println();
        }
    }
}

// 0
// 11
// 222
// 3333
// 44444
class Pattern5 {
    public static void main(String[] args) {
        for (int i = 0; i < 5; i++) {
            for (int j = 0; j <= i; j++) {
                System.out.print(i);
            }
            System.out.println();
        }
    }
}

// *
// **
// ***
// ****
// *****
class Pattern6 {
    public static void main(String[] args) {
        for (int i = 1; i <= 5; i++) {
            for (int j = 5; j > i; j--) {
                System.out.print(" ");
            }
            for (int k = 1; k <= i; k++) {
                System.out.print("*");
            }
            System.out.println();
        }
    }
}

// *****
// ****
// ***
// **
// *
class Pattern7 {
    public static void main(String[] args) {
        for (int i = 5; i >= 1; i--) {
            for (int j = 1; j <= i; j++) {
                System.out.print("*");
            }
            System.out.println();
        }
    }
}

// *****
// ****
// ***
// **
// *
class Pattern8 {
    public static void main(String[] args) {
        for (int i = 1; i <= 5; i++) {
            for (int j = 1; j < i; j++) {
                System.out.print(" ");
            }
            for (int k = 5; k >= i; k--) {
                System.out.print("*");
            }
            System.out.println();
        }
    }
}

// *
// * *
// * * *
// * * * *
// * * * * *
class Pattern9 {
    public static void main(String[] args) {
        for (int i = 1; i <= 5; i++) {
            for (int j = 5; j > i; j--) {
                System.out.print(" ");
            }
            for (int k = 1; k <= i; k++) {
                System.out.print("* ");
            }
            System.out.println();
        }
    }
}

//A
//BC
//DEF
//GHIJ
//KLMNO
class pattern1 {
    public static void main(String[] args) {
        int k = 1;
        for(int i=1; i<=5; i++){
            for(int j=1; j<=i; j++){
                System.out.print((char)(k+64));
                k++;
            }
            System.out.println();
        }
    }
}

//1
//01
//101   
//0101
//10101
class pattern2 {
    public static void main(String[] args) {
        for(int i=1; i<=5; i++){
            for(int j=1; j<=i; j++){
                if((i+j)%2==0){
                    System.out.print("1");
                }else{
                    System.out.print("0");
                }
            }
            System.out.println();
        }
    }
}

//    ****
//   ****
//  ****
// ****
//****
class pattern3 {
    public static void main(String[] args) {
        for(int i=1; i<=5; i++){
            for(int j=1; j<=5-i; j++){
                System.out.print(" ");
            }
            for(int k=1; k<=5; k++){
                System.out.print("*");
            }
            System.out.println();
        }
    }
}

// *
// ***
// *****
// *******
// *********
// *******
// *****
// ***
// *
class Pattern11 {
    public static void main(String[] args) {
        for (int i = 1; i <= 5; i++) {
            for (int j = 5; j > i; j--) {
                System.out.print(" ");
            }
            for (int k = 1; k <= 2 * i - 1; k++) {
                System.out.print("*");
            }
            System.out.println();
        }
        for (int i = 4; i >= 1; i--) {
            for (int j = 5; j > i; j--) {
                System.out.print(" ");
            }
            for (int k = 1; k <= 2 * i - 1; k++) {
                System.out.print("*");
            }
            System.out.println();
        }
    }
}

// 1
// 121
// 12321
// 1234321
// 123454321
class Pattern12 {
    public static void main(String[] args) {
        for (int i = 1; i <= 5; i++) {
            for (int j = 5; j > i; j--) {
                System.out.print(" ");
            }
            for (int k = 1; k <= i; k++) {
                System.out.print(k);
            }
            for (int l = i - 1; l >= 1; l--) {
                System.out.print(l);
            }
            System.out.println();
        }
    }
}

// 1
// 212
// 32123
// 4321234
// 543212345
class Pattern13 {
    public static void main(String[] args) {
        for (int i = 1; i <= 5; i++) {
            for (int j = 5; j > i; j--) {
                System.out.print(" ");
            }
            for (int k = i; k >= 1; k--) {
                System.out.print(k);
            }
            for (int l = 2; l <= i; l++) {
                System.out.print(l);
            }
            System.out.println();
        }
    }
}

// 0
// 15
// 246
// 3579
// 46810
class Pattern14 {
    public static void main(String[] args) {
        int k = 0;
        for (int i = 1; i <= 5; i++) {
            for (int j = 1; j <= i; j++) {
                System.out.print(k);
                k = k + 1;
            }
            System.out.println();
        }
    }
}

//piramid
//     *
//    ***
//   *****
//  *******
// *********
class Pattern15 {
    public static void main(String[] args) {
        for (int i = 1; i <= 5; i++) {
            for (int j = 5; j > i; j--) {
                System.out.print(" ");
            }
            for (int k = 1; k <= 2 * i - 1; k++) {
                System.out.print("*");
            }
            System.out.println();
        }
    }
}
//hollow square
// *****
// *   *
// *   *
// *   *
// *****
class Pattern16 {
    public static void main(String[] args) {
        for (int i = 1; i <= 5; i++) {
            for (int j = 1; j <= 5; j++) {
                if (i == 1 || i == 5 || j == 1 || j == 5) {
                    System.out.print("*");
                } else {
                    System.out.print(" ");
                }
            }
            System.out.println();
        }
    }
}
//diamond pattern
//     *
//    ***
//   *****
//  *******
// *********
//  *******
//   *****
//    ***
//     *
class Pattern17 {
    public static void main(String[] args) {
        for (int i = 1; i <= 5; i++) {
            for (int j = 5; j > i; j--) {
                System.out.print(" ");
            }
            for (int k = 1; k <= 2 * i - 1; k++) {
                System.out.print("*");
            }
            System.out.println();
        }
        for (int i = 4; i >= 1; i--) {
            for (int j = 5; j > i; j--) {
                System.out.print(" ");
            }
            for (int k = 1; k <= 2 * i - 1; k++) {
                System.out.print("*");
            }
            System.out.println();
        }
    }
}

// Iterables:
// 1. It is an interface in Java.
// 2. It is used to iterate the elements of the collection.
// 3. It is used to traverse the elements of the collection.
// 4. It is used to access the elements of the collection.

// Collection:
// 1. It is a framework in Java which is used to store and manipulate the group
// of objects.
// 2. It is used to perform operations like searching, sorting, insertion,
// manipulation, deletion, etc.
// 3. It is used to store the objects dynamically.
// 4. It is used to store the objects of the same type or different types.
// 5. It is used to store the objects in a structured way.
// 6. It is used to store the objects in a single unit.

// Types of Collection:
// 1. List: It is an ordered collection of objects. It allows duplicate
// elements.
// 2. Set: It is an unordered collection of objects. It does not allow duplicate
// elements.
// 3. Map: It is a collection of key-value pairs. It does not allow duplicate
// keys.

// List:
// 1. It is an ordered collection of objects.
// 2. It allows duplicate elements.
// 3. It allows null elements.
// 4. It allows multiple null elements.
// 5. It is an interface in Java.
// 6. It is implemented by ArrayList, LinkedList, Vector, and Stack classes.

// list using vector
class Collection1 {
    public static void main(String[] args) {
        Vector<Integer> list = new Vector<Integer>();
        list.add(1);
        list.add(2);
        list.add(3);
        list.add(4);
        list.add(5);
        list.add(6);
        list.add(7);
        list.add(8);
        list.add(9);
        list.add(10);
        for (int i = 0; i <= list.size(); i++) {
            try {
                System.out.println(list.get(i));
            } catch (Exception e) {
                System.out.println(e);
            }
        }

        // OR
        for (Integer i : list) {
            System.out.println(i);
        }

        // OR
        // printing using enumeration
        //Enumeration e = list.elements();
        Enumeration<Integer> e = list.elements();
        while (e.hasMoreElements()) {
            System.out.println(e.nextElement());
        }

        // OR

        new Vector<Integer>(Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)).forEach(System.out::println);
        // OR
        // Iterator
        Iterator<Integer> itr = list.iterator();
        System.out.println("Using Iterator");
        while (itr.hasNext()) {
            System.out.println(itr.next());
        }

    }
}

// take input from user and print in vector using scanner class
class CollectionInput {
    public static void main(String[] args) {
        Vector<Integer> list = new Vector<Integer>();
        Scanner sc = new Scanner(System.in);
        System.out.println("Enter the number of elements");
        int n = sc.nextInt();
        System.out.println("Enter the elements");
        for (int i = 0; i < n; i++) {
            list.add(sc.nextInt());
        }
        // add vector elements
        System.out.println("Enter another elements");
        list.add(sc.nextInt());
        for (int i = 0; i < list.size(); i++) {
            System.out.println(list.get(i));
        }
        sc.close();
    }
}

// merge two vectors list
class CollectionMerge {
    public static void main(String[] args) {
        Vector<Integer> list1 = new Vector<Integer>(Arrays.asList(1, 2, 3, 4, 5));
        Vector<Integer> list2 = new Vector<Integer>(Arrays.asList(6, 7, 8, 9, 10));

        // inter element at perticular index of list2
        // index = 2, element = 100
        list2.add(2, 100);

        // replace element at perticular index of list2
        // index = 2, element = 99
        list2.set(2, 99);

        // merge two list
        list1.addAll(1, list2);
        for (int i = 0; i < list1.size(); i++) {
            System.out.print(list1.get(i) + "\t");
        }

        // remove element at perticular index of list2
        // index = 2
        list2.remove(2);

        // remove element at perticular element of list2
        // element = 99
        list2.removeElement(99);

        // contains element at perticular element of list2
        // element = 99
        System.out.println(list2.contains(99));

        // indexOf
        // element = 5
        System.out.println(list1.indexOf(5));

        // sort
        Collections.sort(list1);
        for (int i = 0; i < list1.size(); i++) {
            System.out.print(list1.get(i) + "\t");
        }

        // reverse
        Collections.reverse(list1);
        for (int i = 0; i < list1.size(); i++) {
            System.out.print(list1.get(i) + "\t");
        }
        // Comparator
        Collections.sort(list1, new Comparator<Integer>() {
            public int compare(Integer a, Integer b) {
                return a - b;
            }
        });
        for (int i = 0; i < list1.size(); i++) {
            System.out.print(list1.get(i) + "\t");
        }

        // auto boxing
        Vector<Integer> list3 = new Vector<Integer>();
        list3.add(10);
        // ==
        list3.add(Integer.valueOf(5)); // valueOf: convert int to Integer
        // ==
        // list3.add(new Integer(6));

    }
}

// list using ArrayList
class Collection2 {
    public static void main(String[] args) {
        ArrayList<String> list = new ArrayList<String>();
        list.add("Java");
        list.add("Python");
        list.add("C++");
        list.add("C#");
        list.add("Ruby");
        list.add("Java");
        list.add(null);
        list.add(null);
        System.out.println(list);

        // OR
        // printing using iterator
        Iterator<String> itr = list.iterator();
        while (itr.hasNext()) {
            System.out.println(itr.next());
        }

        // OR
        // printing using for each loop
        for (String i : list) {
            System.out.println(i);
        }

        // OR
        // enumeration
        Enumeration<String> e = Collections.enumeration(list);
        while (e.hasMoreElements()) {
            System.out.println(e.nextElement());
        }

    }
}

// Vector vs ArrayList
// 1. Vector is synchronized whereas ArrayList is not synchronized.
// 2. Vector is thread-safe whereas ArrayList is not thread-safe.
// 3. Vector is slow as compared to ArrayList.

class vecvsarr {
    public static void main(String[] args) {
        Vector<Integer> v = new Vector<Integer>();
        ArrayList<Integer> a = new ArrayList<Integer>();
        long start = System.currentTimeMillis();

        // capacity
        System.out.println("Capacity of Vector: " + v.capacity());
        v.ensureCapacity(10000);
        System.out.println("Capacity of Vector: " + v.capacity());

        // ArrayList has no capacity method
        // System.out.println("Capacity of ArrayList: "+a.capacity());

        // speed
        for (int i = 0; i < 1000000; i++) {
            v.add(i);
        }
        long end = System.currentTimeMillis();
        System.out.println("Time taken by Vector: " + (end - start) + "ms");

        start = System.currentTimeMillis();
        for (int i = 0; i < 1000000; i++) {
            a.add(i);
        }
        end = System.currentTimeMillis();
        System.out.println("Time taken by ArrayList: " + (end - start) + "ms");
    }
}

// list using Stack
class Collection4 {
    public static void main(String[] args) {
        Stack<String> list = new Stack<String>();
        list.push("Java");
        list.push("Python");
        list.push("C++");
        list.push("C#");
        list.push("Ruby");
        list.push(null);
        System.out.println(list);
        System.out.println(list.pop());
        System.out.println(list);
        System.out.println(list.peek());
    }
}

// list using LinkedList
class Collection3 {
    public static void main(String[] args) {
        LinkedList<String> list = new LinkedList<String>();
        list.add("Java");
        list.add("Python");
        list.add("C++");
        list.add("C#");
        list.add("Ruby");
        list.add("Java");
        list.add(null);
        list.add(null);
        System.out.println(list);
    }
}

// make own LinkedList
class node {
    int data;
    node next;

    node insertEnd(node n, int data) {
        node temp = new node();
        temp.data = data;
        temp.next = null;
        if (n == null) {
            n = temp;
        }

        node t = n;
        while (t.next != null) {
            t = t.next;
        }
        t.next = temp;
        return n;
    }

    void display(node n) {
        System.out.println("my list");
        while (n != null) {
            System.out.println(n.data);
            n = n.next;
        }
    }

    public static void main(String[] args) {
        node n = new node();
        n = n.insertEnd(n, 10);
        n = n.insertEnd(n, 20);
        n = n.insertEnd(n, 30);
        n = n.insertEnd(n, 40);
        n = n.insertEnd(n, 50);
        n = n.insertEnd(n, 60);
        n = n.insertEnd(n, 70);
        n = n.insertEnd(n, 80);
        n = n.insertEnd(n, 90);
        n = n.insertEnd(n, 100);

        n.display(n);

    }

}

// speed test of list using ArrayList, LinkedList, Stack and Vector
class speedtest {
    public static void main(String[] args) {
        ArrayList<Integer> a = new ArrayList<Integer>();
        LinkedList<Integer> l = new LinkedList<Integer>();
        Stack<Integer> s = new Stack<Integer>();
        Vector<Integer> v = new Vector<Integer>();
        long start = System.currentTimeMillis();
        for (int i = 0; i < 1000000; i++) {
            a.add(i);
        }
        long end = System.currentTimeMillis();
        System.out.println("Time taken by ArrayList: " + (end - start) + "ms");

        start = System.currentTimeMillis();
        for (int i = 0; i < 1000000; i++) {
            l.add(i);
        }
        end = System.currentTimeMillis();
        System.out.println("Time taken by LinkedList: " + (end - start) + "ms");

        start = System.currentTimeMillis();
        for (int i = 0; i < 1000000; i++) {
            s.push(i);
        }
        end = System.currentTimeMillis();
        System.out.println("Time taken by Stack: " + (end - start) + "ms");

        start = System.currentTimeMillis();
        for (int i = 0; i < 1000000; i++) {
            v.add(i);
        }
        end = System.currentTimeMillis();
        System.out.println("Time taken by Vector: " + (end - start) + "ms");
    }
}

// Set:
// 1. It is an unordered collection of objects.
// 2. It does not allow duplicate elements.
// 3. It allows null elements.
// 4. It allows only one null element.
// 5. It is an interface in Java.
// 6. It is implemented by HashSet, LinkedHashSet, and TreeSet classes.

// set using HashSet
class Collection5 {
    public static void main(String[] args) {
        HashSet<String> set = new HashSet<String>();
        set.add("Java");
        set.add("Python");
        set.add("C++");
        set.add("C#");
        set.add("Ruby");
        set.add("Java");
        set.add(null);
        set.add(null);
        System.out.println(set);
    }
}

// set using LinkedHashSet
class Collection6 {
    public static void main(String[] args) {
        LinkedHashSet<String> set = new LinkedHashSet<String>();
        set.add("Java");
        set.add("Python");
        set.add("C++");
        set.add("C#");
        set.add("Ruby");
        set.add("Java");
        set.add(null);
        set.add(null);
        System.out.println(set);
    }
}

// set using TreeSet
class Collection7 {
    public static void main(String[] args) {
        TreeSet<String> set = new TreeSet<String>();
        set.add("Java");
        set.add("Python");
        set.add("C++");
        set.add("C#");
        set.add("Ruby");
        set.add("Java");
        // set.add(null); //null pointer exception
        // set.add(null); //null pointer exception
        System.out.println(set);
    }
}

// Map:
// 1. It is a collection of key-value pairs.
// 2. It does not allow duplicate keys.
// 3. It allows duplicate values.
// 4. It allows only one null key.
// 5. It allows multiple null values.
// 6. It is an interface in Java.
// 7. It is implemented by HashMap, LinkedHashMap, and TreeMap classes.

// map using HashMap
class Collection8 {
    public static void main(String[] args) {
        HashMap<Integer, String> map = new HashMap<Integer, String>();
        map.put(1, "Java");
        map.put(2, "Python");
        map.put(3, "C++");
        map.put(4, "C#");
        map.put(5, "Ruby");
        map.put(1, "Java");
        map.put(null, "Java");
        map.put(null, "Python");
        System.out.println(map);
    }
}

// map using LinkedHashMap
class Collection9 {
    public static void main(String[] args) {
        LinkedHashMap<Integer, String> map = new LinkedHashMap<Integer, String>();
        map.put(1, "Java");
        map.put(2, "Python");
        map.put(3, "C++");
        map.put(4, "C#");
        map.put(5, "Ruby");
        map.put(1, "Java");
        map.put(null, "Java");
        map.put(null, "Python");
        System.out.println(map);
    }
}

// map using TreeMap
class Collection10 {
    public static void main(String[] args) {
        TreeMap<Integer, String> map = new TreeMap<Integer, String>();
        map.put(1, "Java");
        map.put(2, "Python");
        map.put(3, "C++");
        map.put(4, "C#");
        map.put(5, "Ruby");
        map.put(1, "Java");
        // map.put(null, "Java"); //null pointer exception
        // map.put(null, "Python"); //null pointer exception
        System.out.println(map);
    }
}

//Recursion is a method of solving problems that involves breaking a problem down into smaller and smaller subproblems until you get to a small enough problem that it can be solved trivially. Usually recursion involves a function calling itself. While it may not seem like much on the surface, recursion allows us to write elegant solutions to problems that may otherwise be very difficult to program.
//Recursion is a common mathematical and programming concept. It means that a function calls itself. This has the benefit of meaning that you can loop through data to reach a result.
class Recursion {
    public static int sum(int k) {
        if (k > 0) {
            return k + sum(k - 1);
        } else {
            return 0;
        }
    }
    public static void main(String[] args) {
        int result = sum(10);
        System.out.println(result);
    }
}

//objCreation is a class that contains a method to find the sum of natural numbers using recursion. The main method creates an object of the objCreation class and calls the sum method to find the sum of natural numbers from 1 to 10.
class objCreation {
    // method to find the sum of natural numbers
    int sum(int n) {
        if (n != 0)
            return n + sum(n - 1);
        else
            return n;
    }
    public static void main(String[] args) {
        //The *new* keyword is a Java operator that creates the object. It instantiates a class by allocating memory for a new object and returning a reference to that memory. The new keyword also invokes the object constructor.
        objCreation obj = new objCreation();
        int result = obj.sum(10);
        System.out.println(result);
    }
}

//final keyword is used in several different contexts to define an entity that can only be assigned once. Once a final variable has been assigned, it always contains the same value. If a final variable holds a reference to an object, then the state of the object may be changed by operations on the object, but the variable will always refer to the same object.
class FinalKeyword {
    public static void main(String[] args) {
        final int x = 10;
        // x = 20; // Compile time error
        System.out.println(x);
    }
}

//overloading is a concept in which a class has two or more methods with the same name but different parameters. It is similar to constructor overloading in Java. In this example, we have two methods with the same name but different parameters. The first method takes an integer parameter, and the second method takes a string parameter.
class Overloading {
    void display(int a) {
        System.out.println("Integer: " + a);
    }
    void display(String a) {
        System.out.println("String: " + a);
    }
    public static void main(String[] args) {
        Overloading obj = new Overloading();
        obj.display(10);
        obj.display("Hello");
    }
}

//constructor is a special type of method that is used to initialize an object. It is called when an object of a class is created. In this example, we have a class with a constructor that takes an integer parameter. When an object of the class is created, the constructor is called with the specified parameter.
//java constructor: It is a special type of method which is used to initialize the object.
//It has the same name as the class name.
//It does not have any return type.
//It is called when the object is created.
//It is used to initialize the instance variable of the class.
//It is used to allocate memory to the object.
class Constructor
{
    int a;
    Constructor(int n)
    {
        a = n;
    }
    public static void main(String[] args)
    {
        Constructor obj = new Constructor(10);
        System.out.println(obj.a);
    }
}

//0000*0000
//000*0*000
//00*000*00
//0*00000*0
//*0000000*
//0*00000*0
//00*000*00
//000*0*000
//0000*0000
class Pattern18 {
    public static void main(String[] args) {
        for (int i = 1; i <= 5; i++) {
            for (int j = 5; j > i; j--) {
                System.out.print("0");
            }
            for (int k = 1; k <= 2 * i - 1; k++) {
                if (k == 1 || k == 2 * i - 1) {
                    System.out.print("*");
                } else {
                    System.out.print("0");
                }
            }
            for (int l = 5; l > i; l--) {
                System.out.print("0");
            }
            System.out.println();
        }
        for (int i = 4; i >= 1; i--) {
            for (int j = 5; j > i; j--) {
                System.out.print("0");
            }
            for (int k = 1; k <= 2 * i - 1; k++) {
                if (k == 1 || k == 2 * i - 1) {
                    System.out.print("*");
                } else {
                    System.out.print("0");
                }
            }
            for (int l = 5; l > i; l--) {
                System.out.print("0");
            }
            System.out.println();
        }
    }
}

//==============================================26-6-2024==============================================

//INHERTENSE example
class Ain{
    public void name(String[] args) {
        System.out.println("aman");
    }
}
class Bin extends Ain{
    public void roll(){
        System.out.println("255");
    }
}
class Cin extends Bin{
    public void standard(int a){
        System.out.println(a);
    }
}
class inheritance{
    public static void main(String[] args) {
        Cin obj = new Cin();
        obj.name(args);
        obj.roll();
        obj.standard(5);
    }
}

// Aggregation Example
class Engine {
    private String type;

    public Engine(String type) {
        this.type = type;
    }

    public String getType() {
        return type;
    }
}
class Car {
    private String brand;
    private Engine engine;

    public Car(String brand, Engine engine) {
        this.brand = brand;
        this.engine = engine;
    }

    public String getBrand() {
        return brand;
    }

    public Engine getEngine() {
        return engine;
    }
}
class AggregationExample {
    public static void main(String[] args) {
        Engine engine = new Engine("V8");
        Car car = new Car("Ferrari", engine);

        System.out.println("Car brand: " + car.getBrand());
        System.out.println("Engine type: " + car.getEngine().getType());
    }
}
//polymerphism notes
//Polymorphism is a concept in which a single method can have different implementations. It is used to perform a single action in different ways. There are two types of polymorphism in Java: compile-time polymorphism and runtime polymorphism.
//Compile-time polymorphism is also known as method overloading. It occurs when two or more methods in the same class have the same name but different parameters.
//Runtime polymorphism is also known as method overriding. It occurs when a subclass provides a specific implementation of a method that is already defined in its superclass.
//Polymorphism is a key concept in object-oriented programming. It allows objects to be treated as instances of their parent class, which makes it easier to write code that is more flexible and reusable.
//Polymorphism is a powerful feature of Java that allows you to write code that is more flexible and reusable. It is used to perform a single action in different ways, which makes it easier to write code that is more flexible and reusable.

//e.g. of multi level inheritence
class dadaji {
    String[] property = {"BMW"};
}

class pitaji extends dadaji {
    public pitaji() {
        String[] updatedProperty = new String[property.length + 1];
        System.arraycopy(property, 0, updatedProperty, 0, property.length);
        updatedProperty[property.length] = "Cycle";
        property = updatedProperty;
    }
}

class sky extends pitaji {
    public sky() {
        String[] updatedProperty = new String[property.length + 1];
        System.arraycopy(property, 0, updatedProperty, 0, property.length);
        updatedProperty[property.length] = "Bike";
        property = updatedProperty;
    }
}

class multiinherit {
    public static void main(String[] args) {
        sky obj = new sky();
        for (String item : obj.property) {
            System.out.println(item);
        }
    }
}

//runtime polymerphism 
//it is also known as dynamic method dispatch
//Runtime polymorphism is a concept in which a subclass provides a specific implementation of a method that is already defined in its superclass. It is used to achieve runtime polymorphism in Java.
//Process in which a method call to the overridden method is resolved at runtime rather than compile-time.
//In this process, an overridden method is called through the reference variable of a superclass.
//The determination of the method to be called is based on the object being referred to by the reference variable.
//Runtime polymorphism is achieved by method overriding.


//UPCASTING
//Upcasting is the process of casting a subclass object to a superclass reference. It is used to achieve runtime polymorphism in Java. In upcasting, the reference variable of the superclass can refer to the object of the subclass.
//Upcasting is used to achieve runtime polymorphism in Java.
//It is the process of casting a subclass object to a superclass reference.

//If the reference variable of the superclass refers to the object of the subclass, it is known as upcasting.
//Example:-
class Animal {
    void eat() {
        System.out.println("Animal is eating");
    }
}
class Dog extends Animal {
    void eat() {
        System.out.println("Dog is eating");
    }
}
class Upcasting {
    public static void main(String[] args) {
        Animal obj = new Dog();
        obj.eat();
    }
}

//static binding
//Static binding is a process in which the method call is resolved at compile time. It is also known as early binding. In static binding, the method call is resolved based on the reference type of the object.
//Static binding is a process in which the method call is resolved at compile time.
//It is also known as early binding.

//Example:-
class AnimalSt {
    void eat() {
        System.out.println("Animal is eating");
    }
}
class DogSt extends AnimalSt {
    void eat() {
        System.out.println("Dog is eating");
    }
}
class StaticBinding {
    public static void main(String[] args) {
        AnimalSt obj = new DogSt();
        obj.eat();
    }
}

//dynamic binding
//Dynamic binding is a process in which the method call is resolved at runtime. It is also known as late binding. In dynamic binding, the method call is resolved based on the object being referred to by the reference variable.
//Dynamic binding is a process in which the method call is resolved at runtime.
//It is also known as late binding.

//Example:-
class AnimalDy {
    void eat() {
        System.out.println("Animal is eating");
    }
}
class DogDy extends AnimalDy {
    void eat() {
        System.out.println("Dog is eating");
    }
}
class DynamicBinding {
    public static void main(String[] args) {
        AnimalDy obj = new DogDy();
        obj.eat();
    }
}


//abstract class
//An abstract class is a class that cannot be instantiated.
//It is used to define a common interface for a group of subclasses.
//An abstract class can have abstract methods, which are declared but not implemented.
//Subclasses of an abstract class must implement the abstract methods.
//An abstract class can have both abstract and non-abstract methods.
//An abstract class can have constructors, fields, and static methods.
//An abstract class can have final methods, which cannot be overridden by subclasses.
//An abstract class can have static methods, which can be called without creating an object of the class.
//An abstract class can have final fields, which cannot be changed after they are initialized.
//An abstract class can have static fields, which are shared among all instances of the class.
//An abstract class can have static final fields, which are constants.
//An abstract class can have static final methods, which are shared among all instances of the class and cannot be overridden.
//An abstract class can have private methods, which are not visible to subclasses.

//Abstraction is process of hiding the implementation details and showing only functionality to the user.
//Way to achieve abstraction:-
//Abstract class (0 to 100%)
//Interface (100%)

//Rules of abstract class
//An abstract class cannot be instantiated.
//An abstract class can have constructors.
//An abstract class can have fields.
//An abstract class can have methods.
//An abstract class can have abstract methods.
//An abstract class can have non-abstract methods.
//An abstract class can have final methods.
//An abstract class can have static methods.
//An abstract class can have static final methods.
//An abstract class can have final fields.
//An abstract class can have static fields.
//An abstract class can have static final fields.
//An abstract class can have private methods.
//An abstract class can have private fields.
//An abstract class can have private static methods.
//An abstract class can have private static fields.
//An abstract class can have private static final methods.
//An abstract class can have private static final fields.


//Example:-
abstract class AnimalAb {
    abstract void eat();
}
class DogAb extends AnimalAb {
    void eat() {
        System.out.println("Dog is eating");
    }
}
class AbstractClass {
    public static void main(String[] args) {
        AnimalAb obj = new DogAb();
        obj.eat();
    }
}
